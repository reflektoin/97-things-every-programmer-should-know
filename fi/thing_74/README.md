# Polku Suorityskykyyn on täynnä Likaisia Koodipommeja

Useimmiten järjstelmän suorituskyvyn säätäminen vaatii koodin muuttamista. Kun meidän tarvitsee muuttaa koodia, jokainen osa, joka on liiallisen monimutkainen tai laajalti yhteenkytketty(highly coupled), on likainen koodipommi odotamassa ponnistustemme suistamista raiteiltaan. Sotkuisen koodin ensimmäinen uhri on aikataulusi. Jos etenet tasaisesti, sinun on helppo ennustaa valmistuminen. Odottamattomat sotkuisen koodin kohtaamiset vaikeuttavat järkevän arvion tekoa.

Mieti tilannetta, jossa löydät suorituskeskittymän(execution hotspot). Normaali toimintatapa olisi vähentää taustalla olevan algoritmin vahvuutta. Sanotaan, että vastaat pomosi pyyntöön 3-4 tunnin arviolla. Korjatessasi vikaa huomaat rikkoneesi siitä riippuvan osa. Koska lähesisesti liittyvät asiat ovat usein tarpeellisesti yhteenkytkettyjä, tämä särkyminen on todennäköisesti odotettua ja otettu huomioon. Mutta mitä tapahtuu, jos riippuvuuden korjaaminen johtaa muiden riippuvuuksien särkymiseen? Lisäksi, mitä kauempana riippuvuus on aloituspisteestä, sitä epätodennköisemmin tunnistat sen, etkä ota sitä huomioon arvioissasi. Yhtäkkiä 3-4 tunnin arviosi paisuu helposti 3-4 viikkoon. Usein tämä odottamaton inflaatio aikataulussa tapahtuu yksi tai kaksi päivää kerralla. Ei ole harvinaista nähdä "nopean" uudelleenmuotoilun(refactoring) kestävän loputa useita kuukausia. Näissä tapauksissa vahinko tiimin uskottavuuteen ja poliittiseen pääomaan vaihtelee vakavasta parantumattomaan. Kunpa meillä olisi työkalu tunnistamaan ja mittaamaan tätä riskiä.

Itse asiassa meillä on useita tapoja mitata ja hallita koodimme kytkennän(coupling) ja monimutkaisuuden määrää. Ohjelmistomittareita(Software metrics) voidaan käyttää laskemaan tiettyjen piirteiden  määrä koodissamme. Näiden määrä korreloi koodin laadun kanssa. Kaksi monista mittareista, jotka mittaavat kytkennän määrää(coupling) ovat fan-in ja fan-out. Ajattele fan-outtia luokilla: Se määritellään luokan suorien tai epäsuorien viittausten määränä muihin luokkiin. Voit ajatella sitä luokkiena määränä, mikä joudutaan kääntämään, ennen kuin oma luokkasi voidaan kääntää. Fan-in, sen sijaan, on niiden luokkien määrä, joilla on riippuvuus tarkasteltaan luokkaan. Tietäen fan-out ja fan-in -luvut, voimme laskea epävakaus-kertoimen kaavalla *I = f<sub>o</sub> / (f<sub>i</sub> + f<sub>o</sub>)*. Kun *I* lähestyy nollaa, paketista tulee vakaampi. Kun *I* lähestyy 1:stä, paketista tulee epävakaampi. Vakaiden pakettien uudelleenkoodaus on vähäriskistä, kun taas epävakaat paketit sisätävät todennäköisesti likaisia koodipommeja. Tavoitteena uudelleenmuotoilussa on siirtää *I* lähemmäksi nollaa.

Mittareita käyttäessä täytyy muistaa niiden olevan vain nyrkkisääntöjä. Puhtaasti matemaattisesti näemme, että *f<sub>i</sub>* kasvattaminen ilman fo:n muuttamista, siirtää *I*:tä lähemmäksi nollaa. Tämä on kuitenkin erittäin suurien fan-in lukujen haittapuoli, että näitä luokkia voi olla vaikeampi muuttaa, ilman niistä riippuvaisten rikkomista. Lisäksi, ilman fan-out -luvun käsittelyä, et todellisuudessa pienennä riskejäsi, joten jonkilaiseen tasapainoon täytyy pyrkiä.

Yksi ohjelmistomittareiden haittapuoli on, että mittareiden tuottama suuri määrä lukuja voi aiheuttaa epävarmuutta kokemattomille. Siitä huolimatta ohjelmistomittarit voivat olla tehokas työkalu siistiin koodin saavuttamiseksi. Ne voivat auttaa tunnistamaan ja eliminoimaan likaisia koodipommena, ennen kuin ne aiheuttavat vakavan riskin suorituskyvyn säätämiselle.

Kirjoittanut [Kirk Pepperdine](http://programmer.97things.oreilly.com/wiki/index.php/Kirk_Pepperdine)