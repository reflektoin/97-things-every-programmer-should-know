# Prosessien Välinen Kommunikointi Vaikuttaa Sovelluksen Vasteaikaan

Vasteaika on kriittinen sovelluksen käytettävyyden kannalta. Harva asia on ärsyttävämpää kuin sovelluksen vastauksen odottaminen, etenkin kun vuorovaikutuksemme sisältää monia syklejä ärsykkeitä ja vasteita(stimulus and response). Koemme sovelluksen tuhlaavan aikeemme ja vaikuttavan tuottavuuteemme. Mutta hitaan vasteen aiheuttajiin kiinnitetään vähemmän huomiota, etenkin moderneissa sovelluksissa. Suuri osa suorituskyvyn hallinnan (performance management) kirjallisuudesta keskittyy edelleen tietorakenteisiin ja algoritmeihin, asioihin joilla on vaikutusta joissakin tapauksessa, mutta harvemmin dominoivat suorituskykyä moderneissa monitasoisissa liiketoiminta-sovelluksissa(enterprise applicaions).

Kun suorituskyky on sovelluksien ongelma, kokemukseni mukaan tietorakenteet ja algoritmit eivät ole oikea paikka etsiä parannuksia. Vasteaika riippuu vahvasti prosessien välisen komminkoinnin määrästä reaktiona ärsykkeeseen. Vaikka saattaa olla muitakin paikallisia pullonkauloja, prosessien välisen kommunikoinnin määrä yleensä dominoi. Jokainen etäinen prosessien välinen kommunikaatio(remote inter-process communication) lisää latenssia koko vasteaikaan ja nämä yksittäiset lisäykset kertyvät, erityisesti jos ne syntyvät sarjassa.

Ensiluokkainen esimerkki on *ripple loading* sovelluksessa käyttäen olio-relaatio -kuvausta(object-relational mapping). Ripple loading kuvaa useiden tietokantakutsujan peräkkäistä suoritusta valitakseen tiedot, jotka tarvitaan luomaan graafi objekteista (katso [Lazy Load](http://martinfowler.com/eaaCatalog/lazyLoad.html) Martin Fowlerin kirjassa *Patterns of Enterprise Application Architecture*). Kun tietokanta-asiakas on keskitason sovelluspalvelin, joka renderöi verkkosivun, nämä tietokantakutsut yleensä suoritetaan järjestyksessä yksittäisessä säikeessä. Niiden yksittäiset latenssit kasaantuvat ja osallistuvat kokonaisvasteaikaan. Vaikka jokainen tietokantakutsu kestäisi vain 10ms, 1000 kutsua vaativan sivun (mikä ei ole kovin harvinaista) avaamisessa kesäisti ainakin 10 sekuntia. Muita esimerkkejä ovat web-palvelun kutsuminen, HTTP-kutsu selaimelta, hajautettu olion kutsu, pyyntö-vastaus viestintä, ja data-grid -vuorovaikutus erikois-verkkoprotokollalla(custom network protocols). Mitä enemmän etäisten prosessien välistä kommunikointia tarvitaan vastaamiseen, sitä pidempi vasteaika tulee olemaan.

On olemassa muutama melko itsestäänselvä ja yleisesti tiedetty strategia etäisten prosessien välisen kommunikoinnin vähentämiseen. Yksi strategia on soveltaa nuukuuden periaatetta(principle of parsimony), optimoi prosessien välinen rajapintä niin, että vain oikea data siirretään mahdollisimman vähällä vuorovaikutuksella. Toinen strategia on rinnakkaistaa prosessien välistä kommunikointia mahdollisuuksien mukaan, niin että kokonaisvaste johtuu pääosin pisimmän kommunikoinnin latenssista. Kolmas strategia on tallettaa (to cache) aiempien kommunikointien tuloksia, jotta tulevat kommunikoinnin voidaan välttää paikallista muistia käyttämällä.

Kun suunnittelet sovellusta, huomioi prosessien välisten kommunikointien määrä reaktiossa ärsykkeeseen. Analysoidessani hitaasta suorituskyvystä kärsiviä sovelluksia, olen usein huomannut prosessien vlisen kommunikoinnin määrän suhteen reaktioon olevan tuhannen suhde yhteen.

Alkuperäinen kirjoittaja [Randy Stafford](http://programmer.97things.oreilly.com/wiki/index.php/Randy_Stafford)