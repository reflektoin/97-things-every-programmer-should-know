# Liiketoiminnan poikkeuksien erottaminen teknisistä poikkeuksista

On käytännössä kaksi syytä, miksi virheitä tapahtuu ajonaikana (at runtime): tekniset ongelmat, jotka estävät meitä käyttämästä sovellusta ja liiketoiminnan logiikka, joka estää meitä väärinkäyttämästä sovellusta. Useimmat modernit kielet, kuten LISP, Java, Smalltalk ja C# käyttävät poikkeuksia viestimään molemmista tapauksista. Mutta nämä kaksi tapausta ovat niin erilaisia, että niitä pitäisi käsitellä erikseen. Saman poikkeushierarkian ja poikkeusluokan käyttö molemmissa tapauksissa saattaa johtaa sekaannuksiin.

Ratkaisematon tekninen ongelma saattaa aiheutua ohjelmointivirheestä. Esimerkiksi jos yrität lukea 17:sta pituisesta taulukosta 83:tta solua, niin ohjelma on selkeästi hakoteillä ja poikkeus pitäisi syntyä. Hienovaraisempi versio olisi kutsua jonkin kirjaston koodia väärillä argumenteilla, joka aiheuttaisi saman tilanteen kirjaston sisällä.

Olisi virhe yrittää ratkoa nämä tilanteet, jotka itse aiheutit. Sen sijaan annamme poikkeuksen nousta ylimmälle arkkitehtuurin tasolle ja annammme jonkin yleisen poikkeuksenkäsittelijä-mekanismin tehdä mitä se pystyy varmistaakseen järjestelmän vakaan tilan, kuten esimerkiksi transaktion palautus, lokitus ja ylläpidolle(administration) hälyttäminen ja käyttäjälle raportointi(kohteliaasti).

Muunnelma tästä on tilanne, jossa olet "kirjasto tilanteessa" ja kutsuja on rikkonut metodisi sopimuksen, esimerkiksi välittämällä täysin kummallisen argumentin tai riippuvaisen olion väärä tila. Tämä on samalla tasolla yrityksen lukea taulukon 83. solu 17:sta kanssa: kutsujan olisi pitänyt tarkastaa; tekemättä jättäminen on ohjelmoijan virhe asiakkaan puolella(client side). Oikea reaktio on nostaa tekninen poikkeus.

Erilainen, mutta silti tekninen, tilanne tulee ohjelman ollessa kykenemätön jatkamaan ajoympäristön(execution environment) takia, kuten esimerkiksi vastaamaton tietokanta. Tässä tilanteessa täytyy sinun täytyy olettaa, että infrastruktuuri yritti kaikkensa ratkaistakseen tilanteen - yhteyksien korjaaminen ja uudelleentyritys kohtuullisen monta kertaa - ja epäonnistui. Vaikka syy on eri, niin tilanne kutsuvalle koodille on sama: ei ole paljoa mitä se voisi tehdä. Joten viestimme tilanteesta poikkeuksella ja annamme sen nousta yleiseen poikkeuksenkäsittelymekanismiin.

Näihin verrattuna, meillä on tilanne, jossa et voi suorittaa loppuun kutsua sovellusalueen-logiikan(domain-logical) takia. Tässä tapauksessa kohtasimme tilanteen, jossa poikkeus johtuu epätavallisesta tai ei-toivotusta, mutta ei ohjelmallisesta virheestä(programmatically in error). Esimerkiksi jos yritän nostaa rahaa tililtäni, jossa ei ole riittävästi rahaa. Toisin sanoen tämän kaltainen tilanne on osa sopimusta ja poikkeuksen nostaminen on vain *vaihtoehtoinen paluupolku*(return path), joka on osa mallia ja asiakkaan pitäisi olla tietoinen siitä ja valmis käsittelemään se. Näille tapauksille on sopivaa luoda erityinen poikkeus tai erillinen poikkeushierarkia, jotta asiakas voi käsitellä tilanteen omalla tavallaan(in its own terms).

Teknisten ja liiketoiminnan poikkeusten sekoittaminen samaan hierarkiaan sekoittaa niiden eroa ja kutsujaa siitä, mikä metodin sopimus on, mitkä ehdot sen pitää taata ennen kutsumista ja minkä tilanteen sen on tarkoitus pystyä käsittelemään. Tapausten erottaminen selkeyttää ja nostaa todennäköisyyksiä teknisten ongelmien käsittelyyn sovelluskehyksessä(application framework), kun taas liiketoiminnan poikkeukset käsittelee yleensä asiakas-koodi(client code).

Alkuperäinen kirjoittaja By [Dan Bergh Johnsson](http://programmer.97things.oreilly.com/wiki/index.php/Dan_Bergh_Johnsson)